#!/usr/bin/perl
use strict;
use warnings;
use Carp qw/croak/;
use File::Slurp;
use File::Basename;
use File::Spec::Functions qw/catfile catdir/;
use constant POST_HOOK_FILE => '.githook-perltidy';

my $self = basename($0);

sub usage {
    die "usage: $self COMMAND

Valid values for COMMAND include:
    install [MAKE ARGS]       Install pre-commit and post-commit hooks
    pre-commit [MAKE ARGS]    Run perltidy, podtidy and (optionally) tests
    post-commit               Merge non-indexed changes after commit
";
}

sub doit {
    print join( ' ', map { defined $_ ? $_ : '*UNDEF*' } @_ ) . "\n";
    system("@_") == 0 or croak "@_ failed: $?";
}

sub get_perltidyrc {
    my $rc;
    if ( $ENV{GIT_DIR} ) {
        $rc = catfile( $ENV{GIT_DIR}, '..', '.perltidyrc' );
    }
    else {
        $rc = '.perltidyrc';
    }

    if ( system("git ls-files --error-unmatch $rc > /dev/null 2>&1") != 0 ) {
        die "$self: You have no .perltidyrc in your repository.\n";
    }
    return $rc;
}

my $stashed = 0;
my $success = 0;
my $partial = 0;
my $command = shift @ARGV || usage();

if ( $command eq 'install' ) {

    get_perltidyrc();

    my $hooks_dir = catdir( '.git', 'hooks' );
    if ( !-d $hooks_dir ) {
        die "Directory not found: $hooks_dir\n";
    }

    my $pre_file = catfile( $hooks_dir, 'pre-commit' );
    if ( -e $pre_file or -l $pre_file ) {
        die "File/link exists: $pre_file\n";
    }

    my $post_file = catfile( $hooks_dir, 'post-commit' );
    if ( -e $post_file or -l $post_file ) {
        die "File/link exists: $post_file\n";
    }

    write_file( $pre_file, "#!/bin/sh\n$self pre-commit @ARGV\n" );
    chmod 0755, $pre_file || warn "chmod: $!";
    print "$self: $pre_file\n";

    write_file( $post_file, "#!/bin/sh\n$self post-commit\n" );
    chmod 0755, $post_file || warn "chmod: $!";
    print "$self: $post_file\n";

}
elsif ( $command eq 'pre-commit' ) {

    my $rc = get_perltidyrc();

    open( my $fh, '-|', 'git status --porcelain' ) || die "open: $!";

    my @perlfiles;
    while ( my $line = <$fh> ) {
        chomp $line;
        next unless $line =~ m/^(.)(.) (.*)/;

        my ( $index, $wtree, $file ) = ( $1, $2, $3 );
        next unless ( $index eq 'A' or $index eq 'M' );

        if ( $file !~ m/\.(pl|pod|pm|t)$/i ) {
            open( my $fh2, '<', $file ) || die "open $file: $!";
            my $possible = <$fh2> || next;

            #        warn $possible;
            next unless $possible =~ m/^#!.*perl\W/;
        }

        $partial++ if ( $index eq 'M' and $wtree eq 'M' );

        push( @perlfiles, $file );
    }

    exit 0 unless @perlfiles;

    doit( qw/git stash save --quiet --keep-index /,
        $self . ' ' . scalar localtime );
    $stashed = 1;

    doit(qw/git checkout-index -a /);

    foreach my $file (@perlfiles) {
        doit( qw/podtidy --inplace --columns 72/, $file );
        unlink $file . '~';

        unless ( $file =~ m/\.pod$/i ) {
            doit( "perltidy --profile=$rc -nst -b -bext=.bak", $file );
            unlink $file . '.bak';
        }
    }

    if (@ARGV) {

        # Stop the git that is calling this pre-commit script from
        # interfering with any possible git calls in Makefile.PL or any
        # test code
        local %ENV = %ENV;
        delete $ENV{$_} for grep( /^GIT_/, keys %ENV );

        if ( -e 'Makefile.PL' ) {
            doit(qw/perl Makefile.PL/) if grep( /^Makefile.PL$/i, @perlfiles );
            doit(qw/perl Makefile.PL/) unless -f 'Makefile';
        }
        elsif ( -e 'Build.PL' ) {
            doit(qw/perl Build.PL/) if grep( /^Build.PL$/i, @perlfiles );
            doit(qw/perl Build.PL/) unless -f 'Makefile';
        }

        doit( qw/make/, @ARGV );
    }

    doit( qw/git add /, @perlfiles );

    $success = 1;

}
elsif ( $command eq 'post-commit' ) {

    if ( -e POST_HOOK_FILE ) {
        print "$self post-commit:
  Re-applying your non-indexed changes on top of the tidy'd code.
  You may need to fix them up (and pop the top stash) before continuing.\n";

        doit(qw/git stash pop --quiet/);
    }

}
else {
    usage();
}

exit 0;

END {

    # Save our exit status as the system calls in doit() will change it
    my $exit = $?;
    unlink POST_HOOK_FILE;
    if ( defined $command && $command eq 'pre-commit' ) {
        if ($success) {
            if ($partial) {
                print "$self: Writing '"
                  . POST_HOOK_FILE
                  . "' for post-commit hook\n";
                write_file( POST_HOOK_FILE, $$ );
            }
            else {
                doit(qw/git stash drop -q/);
            }
        }
        elsif ($stashed) {
            print STDERR "$self: pre-commit FAIL! Restoring...\n";
            doit(qw/git reset --hard/);
            doit(qw/git stash pop --quiet --index/);
        }
    }
    $? = $exit;
}

__END__

=head1 NAME

githook-perltidy - Run perltidy before Git commits

=head1 VERSION

0.01.

=head1 SYNOPSIS

Make sure everyone uses the same .perltidyrc across your project:

    $ git add .perltidyrc
    $ git commit

Install the pre-commit and post-commit hooks, forcing "make disttest"
to be run after perltidy:

    $ githook-perltidy install disttest
    githook-perltidy: .git/hooks/pre-commit
    githook-perltidy: .git/hooks/post-commit

=head1 DESCRIPTION

B<githook-perltidy> is a script that can be invoked by Git hooks during
a "git commit". It runs L<perltidy> and L<podtidy> on Perl and POD
files (and optionally runs L<make> targets) ensuring that your
project's code is always cleanly committed.

This script is is efficient: it only modifies Perl and POD files that
are being committed and not every file in your repository. It is also
intended to be safe: the index and working tree are stashed away
beforehand, and restored in the event of failure.

There are three types of action this script will take as determed by
the first argument:

=over 4

=item install [MAKE ARGS]

Can be run from the command-line in the top-level directory of your
repository. It writes F<pre-commit> and F<post-commit> hooks in
F<$GIT_DIR/hooks/>. Any MAKE ARGS given will be added to the pre-commit
hook:

$GIT_DIR/hooks/pre-commit:

    #!/bin/sh
    githook-perltidy pre-commit MAKE ARGS

$GIT_DIR/hooks/post-commit:

    #!/bin/sh
    githook-perltidy post-commit

This command will fail if there is no .perltidyrc file in the
repository, if the hooks directory isn't found, or if either of the
hook files already exist.

=item pre-commit [MAKE ARGS]

Should be called from a Git pre-commit hook.  Puts a backup of your
index and working tree into a Git stash. Runs L<perltidy> and
L<podtidy> on any Perl or POD files in the Git index.  If any MAKE ARGS
are given they will be passed to a L<make> call. This way you can
ensure that your code passes a C<make test> or C<make disttest> check
before each commit.

Failure of any of the above commands will result in a hard reset and
the saved stash popped (I.e. re-applied and deleted). The commit will
be stopped.

On success the index is updated with the tidied files and the commit is
allowed to proceed.  In the event that your index was an interactive or
patched version of your working tree, the stash will be kept for the
post-commit hook. Otherwise it will be dropped.

This command will fail if there is no .perltidyrc file in the
repository.

=item post-commit

Should be called from a Git post-commit hook. In the event that your
index was an interactive or patched version of your working tree, the
post-commit command will pop the stash saved by the pre-commit command.
This will attempt to merge back the changes to your working tree that
were not in the index. Note that L<perltidy> and L<podtidy> may have
introduced conflicts with your existing modifications which you will
have to manually fix.

=back

There are two ways in which B<githook-perltidy> behaviour may affect
your existing workflow. Firstly if you are accustomed to commiting
changes to files which are still open in your editor, your editor may
complain that the underlying file has changed on disk. Possibily your
editor doesn't even detect the change and your next write will not be
'tidy'.

Secondly, aborting a commit with an empty commit message or via a later
command in the pre-commit hook will still result in changed (tidied)
files on disk and in the index.

=head1 SUPPORT

This tool is managed via github:

    https://github.com/mlawren/githook-perltidy

=head1 SEE ALSO

L<githooks>(5), L<perltidy>(1), L<podtidy>(1)

=head1 AUTHOR

Mark Lawrence E<lt>nomad@null.netE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright 2011 Mark Lawrence <nomad@null.net>

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

